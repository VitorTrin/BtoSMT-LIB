\chapter{Fundamentação Teórica}\label{chp:LABEL_CHP_2}

\section{Método B e Beta}\label{sec:LABEL_CHP_2_SEC_A}
O Método B é uma metodologia formal para especificação, projeto e codificação
de software \cite{Abrial-1996}. O primeiro passo do método B se dá através da criação de máquinas abstratas, que especificam o comportamento do sistema. Essa máquina passa por vários refinamentos até que seja compreensível para um computador, ao nível de o último passo do refinamento é a implementação.\\
\codejava{Uma possível máquina B para uma ATM}{alg:LABEL_CODE_1}{codigos/ATM.mch}\\
(Botar Referência para de onde saiu esse código)Uma máquina B pode possuir as seguintes cláusulas
\begin{itemize}
	\item MACHINE: Nome da máquina
	\item SETS: Conjuntos utilizados, tanto abstratos como enumerados
	\item CONSTANTS: Constantes a serem usadas
	\item PROPERTIES: Descreve as constantes e conjuntos
	\item VARIABLES: Variáveis locais 
	\item INVARIANTS: Propriedades da variáveis locais que são sempre verdadeiras. Uma variável nunca deve ferir um invariante.
	\item INITIALISATION: Estado inicial da máquina. Todas as variáveis devem possuir um valor inicial
	\item OPERATIONS: Operações da máquina. É dividido em precondição e corpo da operação. Uma operação só pode ser executada se as precondições forem cumpridas.
\end{itemize}

BETA é uma abordagem para geração de casos de teste de unidade a partir
de especificações formais escritas na notação do Método B\cite{BETA-2015}. A partir de do invariante do estado, das precondições e de outros predicados de uma operação, BETA gera testes para cada operação de uma máquina B usando como critério de cobertura o particionamento do espaço de entrada.A ferramenta utilizada atualmente por BETA para gerar os valores de entrada dos teste para cobrir o espaço de entrada, ProB, lida com faixas de valores de modo ineficiente, e só é utilizável em faixas muito reduzidas (a faixa de inteiros default de ProB é de -1 a 3). Qualquer tentativa de ampliar a faixa pode resultar em explosão combinatória.


\section{SMT Solvers e SMT-LIB}\label{sec:LABEL_CHP_2_SEC_B}
Existe um problema chamado problema da satisfatibilidade booleana (conhecido também como boolean satisfiability problem ou SAT), que consiste em determinar se existe pelo menos uma valoração que satisfaz uma fórmula booleana. Para resolver esse problema existem ferramentas, entre elas os resolvedores SAT (SAT solvers), que se utilizam de algoritmos de backtracking. SMT (Satisfiability Modulo Theories) é uma extensão de SAT que permite a adição de mais teorias além da booleana, como arrays e funções não interpretadas, e o problema continua sendo se existe uma valoração que satisfaz a fórmula, embora as variáveis não sejam mais necessariamente booleanas. Para facilitar a comparação, integração e comunicação entre solvers SMT foi criado o Satisfiability Modulo Theories Library (SMT-LIB), que provê diversos recursos, entre eles a linguagem SMT-LIB, criada com objetivo de ser a linguagem padrão para solvers SMT. Essa linguagem é utilizada em SMT-COMP, uma competição anual de benchmarks para solvers SMT.


